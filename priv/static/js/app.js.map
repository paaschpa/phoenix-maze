{"version":3,"sources":["web/static/vendor/phoenix.js","web/static/js/app.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;uBCvrCqB,SAAS;;;;;;;;;AAS9B,IAAI,GAAG,GAAG,EACT;;qBAEc,GAAG","file":"priv\\static\\js\\app.js","sourcesContent":["(function(/*! Brunch !*/) {\r\n  'use strict';\r\n\r\n  var globals = typeof window !== 'undefined' ? window : global;\r\n  if (typeof globals.require === 'function') return;\r\n\r\n  var modules = {};\r\n  var cache = {};\r\n\r\n  var has = function(object, name) {\r\n    return ({}).hasOwnProperty.call(object, name);\r\n  };\r\n\r\n  var expand = function(root, name) {\r\n    var results = [], parts, part;\r\n    if (/^\\.\\.?(\\/|$)/.test(name)) {\r\n      parts = [root, name].join('/').split('/');\r\n    } else {\r\n      parts = name.split('/');\r\n    }\r\n    for (var i = 0, length = parts.length; i < length; i++) {\r\n      part = parts[i];\r\n      if (part === '..') {\r\n        results.pop();\r\n      } else if (part !== '.' && part !== '') {\r\n        results.push(part);\r\n      }\r\n    }\r\n    return results.join('/');\r\n  };\r\n\r\n  var dirname = function(path) {\r\n    return path.split('/').slice(0, -1).join('/');\r\n  };\r\n\r\n  var localRequire = function(path) {\r\n    return function(name) {\r\n      var dir = dirname(path);\r\n      var absolute = expand(dir, name);\r\n      return globals.require(absolute, path);\r\n    };\r\n  };\r\n\r\n  var initModule = function(name, definition) {\r\n    var module = {id: name, exports: {}};\r\n    cache[name] = module;\r\n    definition(module.exports, localRequire(name), module);\r\n    return module.exports;\r\n  };\r\n\r\n  var require = function(name, loaderPath) {\r\n    var path = expand(name, '.');\r\n    if (loaderPath == null) loaderPath = '/';\r\n\r\n    if (has(cache, path)) return cache[path].exports;\r\n    if (has(modules, path)) return initModule(path, modules[path]);\r\n\r\n    var dirIndex = expand(path, './index');\r\n    if (has(cache, dirIndex)) return cache[dirIndex].exports;\r\n    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);\r\n\r\n    throw new Error('Cannot find module \"' + name + '\" from '+ '\"' + loaderPath + '\"');\r\n  };\r\n\r\n  var define = function(bundle, fn) {\r\n    if (typeof bundle === 'object') {\r\n      for (var key in bundle) {\r\n        if (has(bundle, key)) {\r\n          modules[key] = bundle[key];\r\n        }\r\n      }\r\n    } else {\r\n      modules[bundle] = fn;\r\n    }\r\n  };\r\n\r\n  var list = function() {\r\n    var result = [];\r\n    for (var item in modules) {\r\n      if (has(modules, item)) {\r\n        result.push(item);\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n\r\n  globals.require = require;\r\n  globals.require.define = define;\r\n  globals.require.register = define;\r\n  globals.require.list = list;\r\n  globals.require.brunch = true;\r\n})();\r\nrequire.define({'phoenix': function(exports, require, module){ \"use strict\";\r\n\r\nvar _prototypeProperties = function (child, staticProps, instanceProps) { if (staticProps) Object.defineProperties(child, staticProps); if (instanceProps) Object.defineProperties(child.prototype, instanceProps); };\r\n\r\nvar _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } };\r\n\r\n// Phoenix Channels JavaScript client\r\n//\r\n// ## Socket Connection\r\n//\r\n// A single connection is established to the server and\r\n// channels are mulitplexed over the connection.\r\n// Connect to the server using the `Socket` class:\r\n//\r\n//     let socket = new Socket(\"/ws\")\r\n//     socket.connect()\r\n//\r\n// The `Socket` constructor takes the mount point of the socket\r\n// as well as options that can be found in the Socket docs,\r\n// such as configuring the `LongPoll` transport, and heartbeat.\r\n// Socket params can also be passed as an option for default, but\r\n// overridable channel params to apply to all channels.\r\n//\r\n//\r\n// ## Channels\r\n//\r\n// Channels are isolated, concurrent processes on the server that\r\n// subscribe to topics and broker events between the client and server.\r\n// To join a channel, you must provide the topic, and channel params for\r\n// authorization. Here's an example chat room example where `\"new_msg\"`\r\n// events are listened for, messages are pushed to the server, and\r\n// the channel is joined with ok/error matches, and `after` hook:\r\n//\r\n//     let chan = socket.chan(\"rooms:123\", {token: roomToken})\r\n//     chan.on(\"new_msg\", msg => console.log(\"Got message\", msg) )\r\n//     $input.onEnter( e => {\r\n//       chan.push(\"new_msg\", {body: e.target.val})\r\n//           .receive(\"ok\", (message) => console.log(\"created message\", message) )\r\n//           .receive(\"error\", (reasons) => console.log(\"create failed\", reasons) )\r\n//           .after(10000, () => console.log(\"Networking issue. Still waiting...\") )\r\n//     })\r\n//     chan.join()\r\n//         .receive(\"ok\", ({messages}) => console.log(\"catching up\", messages) )\r\n//         .receive(\"error\", ({reason}) => console.log(\"failed join\", reason) )\r\n//         .after(10000, () => console.log(\"Networking issue. Still waiting...\") )\r\n//\r\n//\r\n// ## Joining\r\n//\r\n// Joining a channel with `chan.join(topic, params)`, binds the params to\r\n// `chan.params`. Subsequent rejoins will send up the modified params for\r\n// updating authorization params, or passing up last_message_id information.\r\n// Successful joins receive an \"ok\" status, while unsuccessful joins\r\n// receive \"error\".\r\n//\r\n//\r\n// ## Pushing Messages\r\n//\r\n// From the previous example, we can see that pushing messages to the server\r\n// can be done with `chan.push(eventName, payload)` and we can optionally\r\n// receive responses from the push. Additionally, we can use\r\n// `after(millsec, callback)` to abort waiting for our `receive` hooks and\r\n// take action after some period of waiting.\r\n//\r\n//\r\n// ## Socket Hooks\r\n//\r\n// Lifecycle events of the multiplexed connection can be hooked into via\r\n// `socket.onError()` and `socket.onClose()` events, ie:\r\n//\r\n//     socket.onError( () => console.log(\"there was an error with the connection!\") )\r\n//     socket.onClose( () => console.log(\"the connection dropped\") )\r\n//\r\n//\r\n// ## Channel Hooks\r\n//\r\n// For each joined channel, you can bind to `onError` and `onClose` events\r\n// to monitor the channel lifecycle, ie:\r\n//\r\n//     chan.onError( () => console.log(\"there was an error!\") )\r\n//     chan.onClose( () => console.log(\"the channel has gone away gracefully\") )\r\n//\r\n// ### onError hooks\r\n//\r\n// `onError` hooks are invoked if the socket connection drops, or the channel\r\n// crashes on the server. In either case, a channel rejoin is attemtped\r\n// automatically in an exponential backoff manner.\r\n//\r\n// ### onClose hooks\r\n//\r\n// `onClose` hooks are invoked only in two cases. 1) the channel explicitly\r\n// closed on the server, or 2). The client explicitly closed, by calling\r\n// `chan.leave()`\r\n//\r\n\r\nvar SOCKET_STATES = { connecting: 0, open: 1, closing: 2, closed: 3 };\r\nvar CHAN_STATES = {\r\n  closed: \"closed\",\r\n  errored: \"errored\",\r\n  joined: \"joined\",\r\n  joining: \"joining\" };\r\nvar CHAN_EVENTS = {\r\n  close: \"phx_close\",\r\n  error: \"phx_error\",\r\n  join: \"phx_join\",\r\n  reply: \"phx_reply\",\r\n  leave: \"phx_leave\"\r\n};\r\nvar TRANSPORTS = {\r\n  longpoll: \"longpoll\",\r\n  websocket: \"websocket\"\r\n};\r\n\r\nvar Push = (function () {\r\n\r\n  // Initializes the Push\r\n  //\r\n  // chan - The Channel\r\n  // event - The event, ie `\"phx_join\"`\r\n  // payload - The payload, ie `{user_id: 123}`\r\n  //\r\n\r\n  function Push(chan, event, payload) {\r\n    _classCallCheck(this, Push);\r\n\r\n    this.chan = chan;\r\n    this.event = event;\r\n    this.payload = payload || {};\r\n    this.receivedResp = null;\r\n    this.afterHook = null;\r\n    this.recHooks = [];\r\n    this.sent = false;\r\n  }\r\n\r\n  _prototypeProperties(Push, null, {\r\n    send: {\r\n      value: function send() {\r\n        var _this = this;\r\n\r\n        var ref = this.chan.socket.makeRef();\r\n        this.refEvent = this.chan.replyEventName(ref);\r\n        this.receivedResp = null;\r\n        this.sent = false;\r\n\r\n        this.chan.on(this.refEvent, function (payload) {\r\n          _this.receivedResp = payload;\r\n          _this.matchReceive(payload);\r\n          _this.cancelRefEvent();\r\n          _this.cancelAfter();\r\n        });\r\n\r\n        this.startAfter();\r\n        this.sent = true;\r\n        this.chan.socket.push({\r\n          topic: this.chan.topic,\r\n          event: this.event,\r\n          payload: this.payload,\r\n          ref: ref\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    receive: {\r\n      value: function receive(status, callback) {\r\n        if (this.receivedResp && this.receivedResp.status === status) {\r\n          callback(this.receivedResp.response);\r\n        }\r\n\r\n        this.recHooks.push({ status: status, callback: callback });\r\n        return this;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    after: {\r\n      value: function after(ms, callback) {\r\n        if (this.afterHook) {\r\n          throw \"only a single after hook can be applied to a push\";\r\n        }\r\n        var timer = null;\r\n        if (this.sent) {\r\n          timer = setTimeout(callback, ms);\r\n        }\r\n        this.afterHook = { ms: ms, callback: callback, timer: timer };\r\n        return this;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    matchReceive: {\r\n\r\n      // private\r\n\r\n      value: function matchReceive(_ref) {\r\n        var status = _ref.status;\r\n        var response = _ref.response;\r\n        var ref = _ref.ref;\r\n\r\n        this.recHooks.filter(function (h) {\r\n          return h.status === status;\r\n        }).forEach(function (h) {\r\n          return h.callback(response);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    cancelRefEvent: {\r\n      value: function cancelRefEvent() {\r\n        this.chan.off(this.refEvent);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    cancelAfter: {\r\n      value: function cancelAfter() {\r\n        if (!this.afterHook) {\r\n          return;\r\n        }\r\n        clearTimeout(this.afterHook.timer);\r\n        this.afterHook.timer = null;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    startAfter: {\r\n      value: function startAfter() {\r\n        var _this = this;\r\n\r\n        if (!this.afterHook) {\r\n          return;\r\n        }\r\n        var callback = function () {\r\n          _this.cancelRefEvent();\r\n          _this.afterHook.callback();\r\n        };\r\n        this.afterHook.timer = setTimeout(callback, this.afterHook.ms);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Push;\r\n})();\r\n\r\nvar Channel = exports.Channel = (function () {\r\n  function Channel(topic, params, socket) {\r\n    var _this = this;\r\n\r\n    _classCallCheck(this, Channel);\r\n\r\n    this.state = CHAN_STATES.closed;\r\n    this.topic = topic;\r\n    this.params = params || {};\r\n    this.socket = socket;\r\n    this.bindings = [];\r\n    this.joinedOnce = false;\r\n    this.joinPush = new Push(this, CHAN_EVENTS.join, this.params);\r\n    this.pushBuffer = [];\r\n    this.rejoinTimer = new Timer(function () {\r\n      return _this.rejoinUntilConnected();\r\n    }, this.socket.reconnectAfterMs);\r\n    this.joinPush.receive(\"ok\", function () {\r\n      _this.state = CHAN_STATES.joined;\r\n      _this.rejoinTimer.reset();\r\n    });\r\n    this.onClose(function () {\r\n      _this.socket.log(\"channel\", \"close \" + _this.topic);\r\n      _this.state = CHAN_STATES.closed;\r\n      _this.socket.remove(_this);\r\n    });\r\n    this.onError(function (reason) {\r\n      _this.socket.log(\"channel\", \"error \" + _this.topic, reason);\r\n      _this.state = CHAN_STATES.errored;\r\n      _this.rejoinTimer.setTimeout();\r\n    });\r\n    this.on(CHAN_EVENTS.reply, function (payload, ref) {\r\n      _this.trigger(_this.replyEventName(ref), payload);\r\n    });\r\n  }\r\n\r\n  _prototypeProperties(Channel, null, {\r\n    rejoinUntilConnected: {\r\n      value: function rejoinUntilConnected() {\r\n        this.rejoinTimer.setTimeout();\r\n        if (this.socket.isConnected()) {\r\n          this.rejoin();\r\n        }\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    join: {\r\n      value: function join() {\r\n        if (this.joinedOnce) {\r\n          throw \"tried to join multiple times. 'join' can only be called a single time per channel instance\";\r\n        } else {\r\n          this.joinedOnce = true;\r\n        }\r\n        this.sendJoin();\r\n        return this.joinPush;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onClose: {\r\n      value: function onClose(callback) {\r\n        this.on(CHAN_EVENTS.close, callback);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onError: {\r\n      value: function onError(callback) {\r\n        this.on(CHAN_EVENTS.error, function (reason) {\r\n          return callback(reason);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    on: {\r\n      value: function on(event, callback) {\r\n        this.bindings.push({ event: event, callback: callback });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    off: {\r\n      value: function off(event) {\r\n        this.bindings = this.bindings.filter(function (bind) {\r\n          return bind.event !== event;\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    canPush: {\r\n      value: function canPush() {\r\n        return this.socket.isConnected() && this.state === CHAN_STATES.joined;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    push: {\r\n      value: function push(event, payload) {\r\n        if (!this.joinedOnce) {\r\n          throw \"tried to push '\" + event + \"' to '\" + this.topic + \"' before joining. Use chan.join() before pushing events\";\r\n        }\r\n        var pushEvent = new Push(this, event, payload);\r\n        if (this.canPush()) {\r\n          pushEvent.send();\r\n        } else {\r\n          this.pushBuffer.push(pushEvent);\r\n        }\r\n\r\n        return pushEvent;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    leave: {\r\n\r\n      // Leaves the channel\r\n      //\r\n      // Unsubscribes from server events, and\r\n      // instructs channel to terminate on server\r\n      //\r\n      // Triggers onClose() hooks\r\n      //\r\n      // To receive leave acknowledgements, use the a `receive`\r\n      // hook to bind to the server ack, ie:\r\n      //\r\n      //     chan.leave().receive(\"ok\", () => alert(\"left!\") )\r\n      //\r\n\r\n      value: function leave() {\r\n        var _this = this;\r\n\r\n        return this.push(CHAN_EVENTS.leave).receive(\"ok\", function () {\r\n          _this.log(\"channel\", \"leave \" + _this.topic);\r\n          _this.trigger(CHAN_EVENTS.close, \"leave\");\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onMessage: {\r\n\r\n      // Overridable message hook\r\n      //\r\n      // Receives all events for specialized message handling\r\n\r\n      value: function onMessage(event, payload, ref) {},\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    isMember: {\r\n\r\n      // private\r\n\r\n      value: function isMember(topic) {\r\n        return this.topic === topic;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    sendJoin: {\r\n      value: function sendJoin() {\r\n        this.state = CHAN_STATES.joining;\r\n        this.joinPush.send();\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    rejoin: {\r\n      value: function rejoin() {\r\n        this.sendJoin();\r\n        this.pushBuffer.forEach(function (pushEvent) {\r\n          return pushEvent.send();\r\n        });\r\n        this.pushBuffer = [];\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    trigger: {\r\n      value: function trigger(triggerEvent, payload, ref) {\r\n        this.onMessage(triggerEvent, payload, ref);\r\n        this.bindings.filter(function (bind) {\r\n          return bind.event === triggerEvent;\r\n        }).map(function (bind) {\r\n          return bind.callback(payload, ref);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    replyEventName: {\r\n      value: function replyEventName(ref) {\r\n        return \"chan_reply_\" + ref;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Channel;\r\n})();\r\n\r\nvar Socket = exports.Socket = (function () {\r\n\r\n  // Initializes the Socket\r\n  //\r\n  // endPoint - The string WebSocket endpoint, ie, \"ws://example.com/ws\",\r\n  //                                               \"wss://example.com\"\r\n  //                                               \"/ws\" (inherited host & protocol)\r\n  // opts - Optional configuration\r\n  //   transport - The Websocket Transport, ie WebSocket, Phoenix.LongPoll.\r\n  //               Defaults to WebSocket with automatic LongPoll fallback.\r\n  //   params - The defaults for all channel params, ie `{user_id: userToken}`\r\n  //   heartbeatIntervalMs - The millisec interval to send a heartbeat message\r\n  //   reconnectAfterMs - The optional function that returns the millsec\r\n  //                      reconnect interval. Defaults to stepped backoff of:\r\n  //\r\n  //     function(tries){\r\n  //       return [1000, 5000, 10000][tries - 1] || 10000\r\n  //     }\r\n  //\r\n  //   logger - The optional function for specialized logging, ie:\r\n  //     `logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\r\n  //\r\n  //   longpollerTimeout - The maximum timeout of a long poll AJAX request.\r\n  //                        Defaults to 20s (double the server long poll timer).\r\n  //\r\n  // For IE8 support use an ES5-shim (https://github.com/es-shims/es5-shim)\r\n  //\r\n\r\n  function Socket(endPoint) {\r\n    var _this = this;\r\n\r\n    var opts = arguments[1] === undefined ? {} : arguments[1];\r\n\r\n    _classCallCheck(this, Socket);\r\n\r\n    this.stateChangeCallbacks = { open: [], close: [], error: [], message: [] };\r\n    this.channels = [];\r\n    this.sendBuffer = [];\r\n    this.ref = 0;\r\n    this.transport = opts.transport || window.WebSocket || LongPoll;\r\n    this.heartbeatIntervalMs = opts.heartbeatIntervalMs || 30000;\r\n    this.reconnectAfterMs = opts.reconnectAfterMs || function (tries) {\r\n      return [1000, 5000, 10000][tries - 1] || 10000;\r\n    };\r\n    this.reconnectTimer = new Timer(function () {\r\n      return _this.connect();\r\n    }, this.reconnectAfterMs);\r\n    this.logger = opts.logger || function () {}; // noop\r\n    this.longpollerTimeout = opts.longpollerTimeout || 20000;\r\n    this.params = opts.params || {};\r\n    this.endPoint = \"\" + endPoint + \"/\" + TRANSPORTS.websocket;\r\n  }\r\n\r\n  _prototypeProperties(Socket, null, {\r\n    protocol: {\r\n      value: function protocol() {\r\n        return location.protocol.match(/^https/) ? \"wss\" : \"ws\";\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    endPointURL: {\r\n      value: function endPointURL() {\r\n        var uri = Ajax.appendParams(this.endPoint, this.params);\r\n        if (uri.charAt(0) !== \"/\") {\r\n          return uri;\r\n        }\r\n        if (uri.charAt(1) === \"/\") {\r\n          return \"\" + this.protocol() + \":\" + uri;\r\n        }\r\n\r\n        return \"\" + this.protocol() + \"://\" + location.host + \"\" + uri;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    disconnect: {\r\n      value: function disconnect(callback, code, reason) {\r\n        if (this.conn) {\r\n          this.conn.onclose = function () {}; // noop\r\n          if (code) {\r\n            this.conn.close(code, reason || \"\");\r\n          } else {\r\n            this.conn.close();\r\n          }\r\n          this.conn = null;\r\n        }\r\n        callback && callback();\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    connect: {\r\n      value: function connect() {\r\n        var _this = this;\r\n\r\n        this.disconnect(function () {\r\n          _this.conn = new _this.transport(_this.endPointURL());\r\n          _this.conn.timeout = _this.longpollerTimeout;\r\n          _this.conn.onopen = function () {\r\n            return _this.onConnOpen();\r\n          };\r\n          _this.conn.onerror = function (error) {\r\n            return _this.onConnError(error);\r\n          };\r\n          _this.conn.onmessage = function (event) {\r\n            return _this.onConnMessage(event);\r\n          };\r\n          _this.conn.onclose = function (event) {\r\n            return _this.onConnClose(event);\r\n          };\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    log: {\r\n\r\n      // Logs the message. Override `this.logger` for specialized logging. noops by default\r\n\r\n      value: function log(kind, msg, data) {\r\n        this.logger(kind, msg, data);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onOpen: {\r\n\r\n      // Registers callbacks for connection state change events\r\n      //\r\n      // Examples\r\n      //\r\n      //    socket.onError(function(error){ alert(\"An error occurred\") })\r\n      //\r\n\r\n      value: function onOpen(callback) {\r\n        this.stateChangeCallbacks.open.push(callback);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onClose: {\r\n      value: function onClose(callback) {\r\n        this.stateChangeCallbacks.close.push(callback);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onError: {\r\n      value: function onError(callback) {\r\n        this.stateChangeCallbacks.error.push(callback);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onMessage: {\r\n      value: function onMessage(callback) {\r\n        this.stateChangeCallbacks.message.push(callback);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onConnOpen: {\r\n      value: function onConnOpen() {\r\n        var _this = this;\r\n\r\n        this.log(\"transport\", \"connected to \" + this.endPointURL(), this.transport.prototype);\r\n        this.flushSendBuffer();\r\n        this.reconnectTimer.reset();\r\n        if (!this.conn.skipHeartbeat) {\r\n          clearInterval(this.heartbeatTimer);\r\n          this.heartbeatTimer = setInterval(function () {\r\n            return _this.sendHeartbeat();\r\n          }, this.heartbeatIntervalMs);\r\n        }\r\n        this.stateChangeCallbacks.open.forEach(function (callback) {\r\n          return callback();\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onConnClose: {\r\n      value: function onConnClose(event) {\r\n        this.log(\"transport\", \"close\", event);\r\n        this.triggerChanError();\r\n        clearInterval(this.heartbeatTimer);\r\n        this.reconnectTimer.setTimeout();\r\n        this.stateChangeCallbacks.close.forEach(function (callback) {\r\n          return callback(event);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onConnError: {\r\n      value: function onConnError(error) {\r\n        this.log(\"transport\", error);\r\n        this.triggerChanError();\r\n        this.stateChangeCallbacks.error.forEach(function (callback) {\r\n          return callback(error);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    triggerChanError: {\r\n      value: function triggerChanError() {\r\n        this.channels.forEach(function (chan) {\r\n          return chan.trigger(CHAN_EVENTS.error);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    connectionState: {\r\n      value: function connectionState() {\r\n        switch (this.conn && this.conn.readyState) {\r\n          case SOCKET_STATES.connecting:\r\n            return \"connecting\";\r\n          case SOCKET_STATES.open:\r\n            return \"open\";\r\n          case SOCKET_STATES.closing:\r\n            return \"closing\";\r\n          default:\r\n            return \"closed\";\r\n        }\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    isConnected: {\r\n      value: function isConnected() {\r\n        return this.connectionState() === \"open\";\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    remove: {\r\n      value: function remove(chan) {\r\n        this.channels = this.channels.filter(function (c) {\r\n          return !c.isMember(chan.topic);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    chan: {\r\n      value: function chan(topic) {\r\n        var chanParams = arguments[1] === undefined ? {} : arguments[1];\r\n\r\n        var mergedParams = {};\r\n        for (var key in this.params) {\r\n          mergedParams[key] = this.params[key];\r\n        }\r\n        for (var key in chanParams) {\r\n          mergedParams[key] = chanParams[key];\r\n        }\r\n\r\n        var chan = new Channel(topic, mergedParams, this);\r\n        this.channels.push(chan);\r\n        return chan;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    push: {\r\n      value: function push(data) {\r\n        var _this = this;\r\n\r\n        var topic = data.topic;\r\n        var event = data.event;\r\n        var payload = data.payload;\r\n        var ref = data.ref;\r\n\r\n        var callback = function () {\r\n          return _this.conn.send(JSON.stringify(data));\r\n        };\r\n        this.log(\"push\", \"\" + topic + \" \" + event + \" (\" + ref + \")\", payload);\r\n        if (this.isConnected()) {\r\n          callback();\r\n        } else {\r\n          this.sendBuffer.push(callback);\r\n        }\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    makeRef: {\r\n\r\n      // Return the next message ref, accounting for overflows\r\n\r\n      value: function makeRef() {\r\n        var newRef = this.ref + 1;\r\n        if (newRef === this.ref) {\r\n          this.ref = 0;\r\n        } else {\r\n          this.ref = newRef;\r\n        }\r\n\r\n        return this.ref.toString();\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    sendHeartbeat: {\r\n      value: function sendHeartbeat() {\r\n        this.push({ topic: \"phoenix\", event: \"heartbeat\", payload: {}, ref: this.makeRef() });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    flushSendBuffer: {\r\n      value: function flushSendBuffer() {\r\n        if (this.isConnected() && this.sendBuffer.length > 0) {\r\n          this.sendBuffer.forEach(function (callback) {\r\n            return callback();\r\n          });\r\n          this.sendBuffer = [];\r\n        }\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    onConnMessage: {\r\n      value: function onConnMessage(rawMessage) {\r\n        var msg = JSON.parse(rawMessage.data);\r\n        var topic = msg.topic;\r\n        var event = msg.event;\r\n        var payload = msg.payload;\r\n        var ref = msg.ref;\r\n\r\n        this.log(\"receive\", \"\" + (payload.status || \"\") + \" \" + topic + \" \" + event + \" \" + (ref && \"(\" + ref + \")\" || \"\"), payload);\r\n        this.channels.filter(function (chan) {\r\n          return chan.isMember(topic);\r\n        }).forEach(function (chan) {\r\n          return chan.trigger(event, payload, ref);\r\n        });\r\n        this.stateChangeCallbacks.message.forEach(function (callback) {\r\n          return callback(msg);\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Socket;\r\n})();\r\n\r\nvar LongPoll = exports.LongPoll = (function () {\r\n  function LongPoll(endPoint) {\r\n    _classCallCheck(this, LongPoll);\r\n\r\n    this.endPoint = null;\r\n    this.token = null;\r\n    this.sig = null;\r\n    this.skipHeartbeat = true;\r\n    this.onopen = function () {}; // noop\r\n    this.onerror = function () {}; // noop\r\n    this.onmessage = function () {}; // noop\r\n    this.onclose = function () {}; // noop\r\n    this.pollEndpoint = this.normalizeEndpoint(endPoint);\r\n    this.readyState = SOCKET_STATES.connecting;\r\n\r\n    this.poll();\r\n  }\r\n\r\n  _prototypeProperties(LongPoll, null, {\r\n    normalizeEndpoint: {\r\n      value: function normalizeEndpoint(endPoint) {\r\n        return endPoint.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\").replace(new RegExp(\"(.*)/\" + TRANSPORTS.websocket), \"$1/\" + TRANSPORTS.longpoll);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    endpointURL: {\r\n      value: function endpointURL() {\r\n        return Ajax.appendParams(this.pollEndpoint, {\r\n          token: this.token,\r\n          sig: this.sig,\r\n          format: \"json\"\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    closeAndRetry: {\r\n      value: function closeAndRetry() {\r\n        this.close();\r\n        this.readyState = SOCKET_STATES.connecting;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    ontimeout: {\r\n      value: function ontimeout() {\r\n        this.onerror(\"timeout\");\r\n        this.closeAndRetry();\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    poll: {\r\n      value: function poll() {\r\n        var _this = this;\r\n\r\n        if (!(this.readyState === SOCKET_STATES.open || this.readyState === SOCKET_STATES.connecting)) {\r\n          return;\r\n        }\r\n\r\n        Ajax.request(\"GET\", this.endpointURL(), \"application/json\", null, this.timeout, this.ontimeout.bind(this), function (resp) {\r\n          if (resp) {\r\n            var status = resp.status;\r\n            var token = resp.token;\r\n            var sig = resp.sig;\r\n            var messages = resp.messages;\r\n\r\n            _this.token = token;\r\n            _this.sig = sig;\r\n          } else {\r\n            var status = 0;\r\n          }\r\n\r\n          switch (status) {\r\n            case 200:\r\n              messages.forEach(function (msg) {\r\n                return _this.onmessage({ data: JSON.stringify(msg) });\r\n              });\r\n              _this.poll();\r\n              break;\r\n            case 204:\r\n              _this.poll();\r\n              break;\r\n            case 410:\r\n              _this.readyState = SOCKET_STATES.open;\r\n              _this.onopen();\r\n              _this.poll();\r\n              break;\r\n            case 0:\r\n            case 500:\r\n              _this.onerror();\r\n              _this.closeAndRetry();\r\n              break;\r\n            default:\r\n              throw \"unhandled poll status \" + status;\r\n          }\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    send: {\r\n      value: function send(body) {\r\n        var _this = this;\r\n\r\n        Ajax.request(\"POST\", this.endpointURL(), \"application/json\", body, this.timeout, this.onerror.bind(this, \"timeout\"), function (resp) {\r\n          if (!resp || resp.status !== 200) {\r\n            _this.onerror(status);\r\n            _this.closeAndRetry();\r\n          }\r\n        });\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    close: {\r\n      value: function close(code, reason) {\r\n        this.readyState = SOCKET_STATES.closed;\r\n        this.onclose();\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return LongPoll;\r\n})();\r\n\r\nvar Ajax = exports.Ajax = (function () {\r\n  function Ajax() {\r\n    _classCallCheck(this, Ajax);\r\n  }\r\n\r\n  _prototypeProperties(Ajax, {\r\n    request: {\r\n      value: function request(method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n        if (window.XDomainRequest) {\r\n          var req = new XDomainRequest(); // IE8, IE9\r\n          this.xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback);\r\n        } else {\r\n          var req = window.XMLHttpRequest ? new XMLHttpRequest() : // IE7+, Firefox, Chrome, Opera, Safari\r\n          new ActiveXObject(\"Microsoft.XMLHTTP\"); // IE6, IE5\r\n          this.xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback);\r\n        }\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    xdomainRequest: {\r\n      value: function xdomainRequest(req, method, endPoint, body, timeout, ontimeout, callback) {\r\n        var _this = this;\r\n\r\n        req.timeout = timeout;\r\n        req.open(method, endPoint);\r\n        req.onload = function () {\r\n          var response = _this.parseJSON(req.responseText);\r\n          callback && callback(response);\r\n        };\r\n        if (ontimeout) {\r\n          req.ontimeout = ontimeout;\r\n        }\r\n\r\n        // Work around bug in IE9 that requires an attached onprogress handler\r\n        req.onprogress = function () {};\r\n\r\n        req.send(body);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    xhrRequest: {\r\n      value: function xhrRequest(req, method, endPoint, accept, body, timeout, ontimeout, callback) {\r\n        var _this = this;\r\n\r\n        req.timeout = timeout;\r\n        req.open(method, endPoint, true);\r\n        req.setRequestHeader(\"Content-Type\", accept);\r\n        req.onerror = function () {\r\n          callback && callback(null);\r\n        };\r\n        req.onreadystatechange = function () {\r\n          if (req.readyState === _this.states.complete && callback) {\r\n            var response = _this.parseJSON(req.responseText);\r\n            callback(response);\r\n          }\r\n        };\r\n        if (ontimeout) {\r\n          req.ontimeout = ontimeout;\r\n        }\r\n\r\n        req.send(body);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    parseJSON: {\r\n      value: function parseJSON(resp) {\r\n        return resp && resp !== \"\" ? JSON.parse(resp) : null;\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    serialize: {\r\n      value: function serialize(obj, parentKey) {\r\n        var queryStr = [];\r\n        for (var key in obj) {\r\n          if (!obj.hasOwnProperty(key)) {\r\n            continue;\r\n          }\r\n          var paramKey = parentKey ? \"\" + parentKey + \"[\" + key + \"]\" : key;\r\n          var paramVal = obj[key];\r\n          if (typeof paramVal === \"object\") {\r\n            queryStr.push(this.serialize(paramVal, paramKey));\r\n          } else {\r\n            queryStr.push(encodeURIComponent(paramKey) + \"=\" + encodeURIComponent(paramVal));\r\n          }\r\n        }\r\n        return queryStr.join(\"&\");\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    appendParams: {\r\n      value: function appendParams(url, params) {\r\n        if (Object.keys(params).length === 0) {\r\n          return url;\r\n        }\r\n\r\n        var prefix = url.match(/\\?/) ? \"&\" : \"?\";\r\n        return \"\" + url + \"\" + prefix + \"\" + this.serialize(params);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Ajax;\r\n})();\r\n\r\nAjax.states = { complete: 4 };\r\n\r\n// Creates a timer that accepts a `timerCalc` function to perform\r\n// calculated timeout retries, such as exponential backoff.\r\n//\r\n// ## Examples\r\n//\r\n//    let reconnectTimer = new Timer(() => this.connect(), function(tries){\r\n//      return [1000, 5000, 10000][tries - 1] || 10000\r\n//    })\r\n//    reconnectTimer.setTimeout() // fires after 1000\r\n//    reconnectTimer.setTimeout() // fires after 5000\r\n//    reconnectTimer.reset()\r\n//    reconnectTimer.setTimeout() // fires after 1000\r\n//\r\n\r\nvar Timer = (function () {\r\n  function Timer(callback, timerCalc) {\r\n    _classCallCheck(this, Timer);\r\n\r\n    this.callback = callback;\r\n    this.timerCalc = timerCalc;\r\n    this.timer = null;\r\n    this.tries = 0;\r\n  }\r\n\r\n  _prototypeProperties(Timer, null, {\r\n    reset: {\r\n      value: function reset() {\r\n        this.tries = 0;\r\n        clearTimeout(this.timer);\r\n      },\r\n      writable: true,\r\n      configurable: true\r\n    },\r\n    setTimeout: {\r\n\r\n      // Cancels any previous setTimeout and schedules callback\r\n\r\n      value: (function (_setTimeout) {\r\n        var _setTimeoutWrapper = function setTimeout() {\r\n          return _setTimeout.apply(this, arguments);\r\n        };\r\n\r\n        _setTimeoutWrapper.toString = function () {\r\n          return _setTimeout.toString();\r\n        };\r\n\r\n        return _setTimeoutWrapper;\r\n      })(function () {\r\n        var _this = this;\r\n\r\n        clearTimeout(this.timer);\r\n\r\n        this.timer = setTimeout(function () {\r\n          _this.tries = _this.tries + 1;\r\n          _this.callback();\r\n        }, this.timerCalc(this.tries + 1));\r\n      }),\r\n      writable: true,\r\n      configurable: true\r\n    }\r\n  });\r\n\r\n  return Timer;\r\n})();\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n  value: true\r\n});\r\n }});\r\nif(typeof(window) === 'object' && !window.Phoenix){ window.Phoenix = require('phoenix') };\r\n\r\n","import {Socket} from \"phoenix\"\n\n// let socket = new Socket(\"/ws\")\n// socket.connect()\n// let chan = socket.chan(\"maze:lobby\", {})\n// chan.join().receive(\"ok\", chan => {\n//   console.log(\"Success!\")\n// })\n\nlet App = {\n}\n\nexport default App\n"]}